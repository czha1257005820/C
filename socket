/** 
* @file sdk_srv_main.c
*
* @note V1.0 initial
*/

#include "sdk_srv_external.h"
#include "configTypes.h"
#include "gDefinitions.h"
#include "util/util_hpr_include.h"
#include "util/util_thread.h"
#include "sdk_srv_cfg.h"
#include "sdk_srv_proto.h"
#include "sdk_srv_debug.h"
#include "sdk_srv_core.h"
#include "sdk_srv_misc.h"
#include "sdk_srv_util.h"
#include "user_if_cfg_api.h"
#include "security.h"

extern HPR_BOOL abi_sup_ipv6(HPR_VOID);
extern int get_ipPort(void);
extern HPR_INT32 sdk_srv_notSup_cmd(HPR_SOCK_T iConnFd, HPR_INT8 *pRecvBuff);

static HPR_BOOL bDeviceActive = HPR_FALSE;/*设备是否已激活*/

typedef struct
{
    HPR_BOOL  bRun;        /*服务是否已经运行*/
    HPR_BOOL  bNeedQuit;   /*是否停止SDK 服务*/
    HPR_INT32 iThreadCnt;  /*服务并发处理线程数*/
    HPR_INT32 iPort;       /*监听端口*/
    HPR_INT32 aNatIdx[PAL_MAX_ETHERNET];  /*端口映射*/
}SDK_SRV_STAT_T;

static SDK_SRV_ARRAY_T s_struSdkSrvArray;

static SDK_SRV_STAT_T s_struSdkSrvStat;

IMPORT HPR_BOOL g_bSystemStart;

static int sdk_srv_int(void)
{
    int i;
    static HPR_BOOL bInit = HPR_FALSE;

    if(bInit)
    {
        return HPR_OK;
    }

    bInit = HPR_TRUE;
    s_struSdkSrvStat.bRun = HPR_FALSE;
    s_struSdkSrvStat.bNeedQuit = HPR_FALSE;
    s_struSdkSrvStat.iThreadCnt = 0;
    s_struSdkSrvStat.iPort = 0;

    for(i=0; i<PAL_MAX_ETHERNET; i++)
    {
        s_struSdkSrvStat.aNatIdx[i] = -1;
    }

    return HPR_OK;
}

/*
 *@fn    sdk_srv_proc_srv
 *@brief 服务处理
 *@param [in] iConnFd 通信套接字
 
 *@return HPR_OK/HPR_ERROR
*/
static HPR_VOID sdk_srv_proc_srv(HPR_SOCK_T iConnFd, HPR_INT32 iHasReadLen)
{
    HPR_INT32 iRet = HPR_ERROR;
    SDK_SRV_ITEM_T  struSrvItem;
    NETCMD_HEADER   struSrvCmdHeader;
    HPR_INT32 iCmdLen = 0, iLeftLen=0;
    HPR_INT32 iSockErrNo = HPR_SOCKET_STATUS_OK;
    char pTaskName[MAX_PTHREAD_NAME+1]={'\0'};
    char byRcvBuf[SDK_SRV_PROTO_BUF_LEN], *pRcvBuff = NULL, *pDynBuf = NULL;

    time_t sTime;
    HPR_INT32 nread;
    HPR_INT32 i32SockErrNo = HPR_SOCKET_STATUS_OK;
    CFG_DEVICE_STATUS_T struActiveStatus;
    
    /* 在任务列表中记录任务名称 */
    strncpy(pTaskName, "taskSdkSrvProc", sizeof(pTaskName));
    pushPthreadInfo(pTaskName, strlen(pTaskName));

    bzero(byRcvBuf, sizeof(byRcvBuf));
    bzero(&struSrvCmdHeader, sizeof(struSrvCmdHeader));
    if (0 == iHasReadLen)
    {
        if(sizeof(iCmdLen) != HPR_Recvn_WithErr(iConnFd, &iCmdLen, sizeof(iCmdLen)
                                            , SDK_SRV_SOCK_WAIT_TIME, &iSockErrNo))
        {
            SDK_SRV_ERR("HPR_Recvn_WithErr failed:%d\n", iSockErrNo);
            goto errExit;
        }
        iCmdLen = ntohl(iCmdLen);   
    }
    else
    {
        iCmdLen = iHasReadLen;
    }

    SDK_SRV_INFO("Command length = 0x%0x\n", iCmdLen);
    if(iCmdLen>=24 && iCmdLen<=SDK_SRV_PROTO_MAX_LEN)
    {
        /* valid command length */
        iLeftLen = iCmdLen - 4;
        if(iCmdLen<=SDK_SRV_PROTO_BUF_LEN)
        {
            pRcvBuff = byRcvBuf;
        }
        else
        {
            pDynBuf = (char *)malloc(iCmdLen + 1);/* 防止SDK走xml协议时，数据最后没有'\0'*/
            if(!pDynBuf)
            {
                SDK_SRV_ERR("malloc failed.\n");
                goto errExit;
            }
            pRcvBuff = pDynBuf;
        }
        
        if(iLeftLen != HPR_Recvn_WithErr(iConnFd, pRcvBuff+4, iLeftLen
                                    , SDK_SRV_SOCK_WAIT_TIME, &iSockErrNo))
        {
            SDK_SRV_ERR("HPR_Recvn_WithErr failed:%d-%d\n", iSockErrNo, iLeftLen);
            goto errExit;
        }

        *(HPR_UINT32 *)pRcvBuff = htonl(iCmdLen);
        memcpy((char *)&struSrvCmdHeader, pRcvBuff, sizeof(NETCMD_HEADER));
        struSrvCmdHeader.netCmd = ntohl(struSrvCmdHeader.netCmd);
        /*放开打印信息，方便定位SDK命令*/
        SDK_SRV_INFO(" ^^^^^^^^^^^^^^^^^ product 3.5.20 :proc new sdk srv:0x%06x @@@@@@@@@@@@@@@@@@@ \n", struSrvCmdHeader.netCmd);
        SDK_SRV_INFO("UserId is %d\n", ntohl(struSrvCmdHeader.userID));
        if(HPR_OK != sdk_srv_decrypt_msg(pRcvBuff))
        {
            SDK_SRV_ERR("sdk decrypt msg error!\n");
            goto errExit;
        }
        

        /*检查设备是否已激活可以放到start函数里面*/
        if(HPR_FALSE == bDeviceActive)/*设备未激活*/
        {
            bzero(&struActiveStatus, sizeof(struActiveStatus));
            (void)if_get_device_status_cfg(&struActiveStatus);
            bDeviceActive = struActiveStatus.bDeviceActive;
        }

        if(HPR_TRUE !=  bDeviceActive)/*未激活*/
        {
            SDK_SRV_INFO("the device not active!\n");
            if(SDK_SRV_DVR_ACTIVATE != struSrvCmdHeader.netCmd)/*未激活情况下只能进行激活操作*/
            {
                SDK_SRV_ERR("sdk srv:0x%x the device not ACTVIE!!!\n", struSrvCmdHeader.netCmd);
                (void)sdk_srv_send_retval(iConnFd, SDK_SRV_ERROR_DEVICE_NOT_ACTIVATED);
                goto errExit;
            }
        }

        if((SDK_SRV_DVR_ACTIVATE != struSrvCmdHeader.netCmd) 
                && (SDK_SRV_LOGIN != struSrvCmdHeader.netCmd)
                && (SDK_SRV_RELOGIN != struSrvCmdHeader.netCmd)
                && (SDK_SRV_RUDP_PREV != struSrvCmdHeader.netCmd)
                && (SDK_SRV_ZERO_RUDP_PREV != struSrvCmdHeader.netCmd)
                && (SDK_SRV_TRANS_IPC_FUN != struSrvCmdHeader.netCmd))
        {
            struSrvCmdHeader.checkSum = ntohl(struSrvCmdHeader.checkSum);
            struSrvCmdHeader.userID = ntohl(struSrvCmdHeader.userID);
            iRet = sdk_srv_check_sum_valid(&struSrvCmdHeader);
            if(NETRET_QUALIFIED != iRet)
            {
                SDK_SRV_ERR("sdk srv sum check error: %d!\n", iRet);
                (void)sdk_srv_send_retval(iConnFd, iRet);
                goto errExit;
            }
        }

        popPthreadInfo(pTaskName, strlen(pTaskName));
        snprintf(pTaskName, sizeof(pTaskName), "taskSdkSrv0x%x", struSrvCmdHeader.netCmd);
        pushPthreadInfo(pTaskName, strlen(pTaskName));
        
        bzero(&struSrvItem, sizeof(struSrvItem));
        struSrvItem.dwCmd = struSrvCmdHeader.netCmd;
        sdk_srv_find_srv(&s_struSdkSrvArray, &struSrvItem);
        if(struSrvItem.pSrvProc)
        {
            iRet = (*struSrvItem.pSrvProc)(iConnFd, pRcvBuff);
            SDK_SRV_INFO("sdk srv:0x%x ret is:%d\n", struSrvCmdHeader.netCmd, iRet);
            if(struSrvItem.bCloseSock) /*该服务内部会关闭socket*/
            {
                iConnFd = HPR_INVALID_SOCKET;  
            }
        }
        else
        {
            SDK_SRV_INFO("sdk srv:0x%x not support(nvr)!\n", struSrvCmdHeader.netCmd);
            iRet = sdk_srv_notSup_cmd(iConnFd, pRcvBuff);
        }        
    }
    else
    {
        SDK_SRV_ERR("sdk srv data len invalid:%d!\n", iCmdLen);
        iRet = HPR_ERROR;
    }
errExit:

    //内部接口返回error直接关Fd
    if(HPR_ERROR != iRet)/*目前不频繁调用if接口获取状态，目前sdk也没在用这个字段，先写死*/
    //if(HPR_FALSE == sdk_abi_socket_security_no_wait(ntohl(struSrvCmdHeader.userID)))
    {
        if(HPR_INVALID_SOCKET != iConnFd)
        {
            sTime = time(NULL);
            while((nread = HPR_Recvn_WithErr(iConnFd, pRcvBuff, 1, 5000, &i32SockErrNo)) > 0)
            {
                //NET_INFO("Read %d byte.\n", nread);
                usleep(100000);
                if((time(NULL)-sTime)>120)  /* wait up to 120 seconds */
                {       
                    nread = ERROR;
                    break;
                }
            }
        }
    }
    
    sdk_srv_close_conn(iConnFd);
    
    SAFE_FREE(pDynBuf);
    
    popPthreadInfo(pTaskName, strlen(pTaskName));

    s_struSdkSrvStat.iThreadCnt--;
    
    return;
}

HPR_VOID sdk_srv_start(HPR_VOID)
{
    int i, iPort;
    U_IN_ADDR struPeer;
    HPR_SOCK_T sockFd, connFd;
    HPR_ADDR_T struLocalAddr;
    char pTaskName[MAX_PTHREAD_NAME+1] = {'\0'};
    HPR_INT32 iAddrFamly = AF_INET;
    HPR_UINT32 local_ip = inet_addr("127.0.0.1");
    const struct in6_addr struLoop6 = IN6ADDR_LOOPBACK_INIT;
    HPR_INT32 iHasReadLen = 0;
    HPR_INT32 iSockErrNo = HPR_SOCKET_STATUS_OK;

    while(1)
    {
        if(g_bSystemStart == HPR_TRUE)
        {
            break;
        }
        else
        {
            sleep(1);
        }
    }

    
    if(s_struSdkSrvStat.bRun)
    {
        SDK_SRV_ERR("sdk srv is running!\n");
        return;
    }
    if(HPR_OK != sdk_srv_int())
    {
        SDK_SRV_ERR("sdk srv init error!\n");
        return;
    }
    s_struSdkSrvStat.bRun = HPR_TRUE;
    s_struSdkSrvStat.bNeedQuit = HPR_FALSE;

    bzero(pTaskName, sizeof(pTaskName));
    snprintf(pTaskName,sizeof(pTaskName), "%s", "taskDvrNetServer");
    pushPthreadInfo(pTaskName, strlen(pTaskName));

    sdk_srv_init_srv_array(&s_struSdkSrvArray);
        
flush_port:

    bzero(&struLocalAddr, sizeof(struLocalAddr));
    iAddrFamly = abi_sup_ipv6()?AF_INET6:AF_INET;
    sockFd = HPR_CreateSocket(iAddrFamly, SOCK_STREAM, 0);
    if(HPR_INVALID_SOCKET == sockFd)
    {
        s_struSdkSrvStat.bRun = HPR_FALSE;
        SDK_SRV_ERR("HPR_CreateSocket failed \n");
        return;
    }

    iPort = get_ipPort();
    if(s_struSdkSrvStat.iPort != iPort)
    {
        for(i=0; i<PAL_MAX_ETHERNET; i++)
        {
            if(s_struSdkSrvStat.aNatIdx[i] > -1)
            {
                if(HPR_OK != nui_if_del_virtual_host(s_struSdkSrvStat.aNatIdx[i]))
                {
                    SDK_SRV_ERR("======sdk srv del virtual host: %d error!\n", s_struSdkSrvStat.iPort);
                }
                SDK_SRV_ERR("======delete virtual host[%d]\n", s_struSdkSrvStat.aNatIdx[i]);
            }
        }

        if(HPR_OK != nui_if_add_virtual_host_v1(HPR_TRUE, iPort, iPort, 1, s_struSdkSrvStat.aNatIdx))
        {
            SDK_SRV_ERR("======sdk srv add virtual host: %d error!\n", iPort);
        }
    }
    
    //直接可以用iPort
    s_struSdkSrvStat.iPort = iPort;
    if(HPR_OK != HPR_MakeAddrByString(iAddrFamly, NULL
                , (HPR_UINT16)s_struSdkSrvStat.iPort, &struLocalAddr))
    {
        s_struSdkSrvStat.bRun = HPR_FALSE;
        HPR_CloseSocket(sockFd);
        popPthreadInfo(pTaskName, strlen(pTaskName));
        SDK_SRV_ERR("HPR_MakeAddrByString error!\n");
        return;
    }
    
    if(HPR_OK != HPR_SetReuseAddr(sockFd, HPR_TRUE))
    {
        s_struSdkSrvStat.bRun = HPR_FALSE;
        HPR_CloseSocket(sockFd);
        SDK_SRV_ERR("HPR_SetReuseAddr error!\n");
        return;
    }
    
    for(i = 0 ; i < 5 ; i++)    /*防止配置的端口号，之前有其他服务在使用，但是尚未完成退出*/
    {
        if(HPR_OK == HPR_Bind(sockFd, &struLocalAddr))
        {
            SDK_SRV_INFO("HPR_Bind succes!\n");
            break;
        }
        sleep(5);
    }
    
    if(5 == i)
    {
        s_struSdkSrvStat.bRun = HPR_FALSE;
        HPR_CloseSocket(sockFd);
        popPthreadInfo(pTaskName, strlen(pTaskName));
        SDK_SRV_ERR("HPR_Bind failed\n");
        return;
    }

    if(HPR_OK != HPR_Listen(sockFd, SDK_SRV_LISTENQ))
    {
        s_struSdkSrvStat.bRun = HPR_FALSE;
        HPR_CloseSocket(sockFd);
        popPthreadInfo(pTaskName, strlen(pTaskName));
        SDK_SRV_ERR("HPR_Listen failed\n");
        return;
    }    

    while(!s_struSdkSrvStat.bNeedQuit) 
    {
        /* accept a connection from a socket */
        connFd = HPR_Accept(sockFd, NULL, HPR_INFINITE);
        if(HPR_INVALID_SOCKET == connFd)
        {
            HPR_Sleep(500);
            SDK_SRV_ERR("Accept() failed errno=%d.\n",HPR_GetSystemLastError());         
            continue;
        }

        iHasReadLen = 0;
        bzero(&struPeer, sizeof(struPeer));
        (void)sdk_srv_get_peer_addr(connFd, &struPeer);
        if((struPeer.v4.s_addr == local_ip) || !(memcmp(&struPeer.v6, &struLoop6, sizeof(struct in6_addr))))
        {
            if (sizeof(iHasReadLen) != HPR_Recvn_WithErr(connFd, &iHasReadLen, sizeof(iHasReadLen), SDK_SRV_SOCK_WAIT_TIME, &iSockErrNo))
            {
                SDK_SRV_ERR("HPR_Recvn_WithErr failed:%d\n", iSockErrNo);
                HPR_CloseSocket(connFd);
                connFd = HPR_INVALID_SOCKET;
                HPR_Sleep(500);
                continue;
            }        

            /**
             * 通过命令长度判断是否需要bFlushPort，127.0.0.1发送SDK_SRV_PROTO_MAX_LEN + 1
             */        
            iHasReadLen = ntohl(iHasReadLen);   
            if (!((iHasReadLen >= 24) && (iHasReadLen <= SDK_SRV_PROTO_MAX_LEN)))
            {
                if (SDK_SRV_PROTO_MAX_LEN + 1 == iHasReadLen)
                {
                    SDK_SRV_INFO("Port has been changed, goto flush_port.\n");
                    
                    HPR_CloseSocket(sockFd);
                    sockFd = HPR_INVALID_SOCKET;
                    
                    HPR_CloseSocket(connFd);
                    connFd = HPR_INVALID_SOCKET;
                    HPR_Sleep(500);
                    goto flush_port;
                }
                else
                {                
                    SDK_SRV_ERR("cmd length error[%d].\n", iHasReadLen);
                    
                    HPR_CloseSocket(connFd);
                    connFd = HPR_INVALID_SOCKET;
                    HPR_Sleep(500);
                    continue;
                }
            }
        }

        if(s_struSdkSrvStat.iThreadCnt > SDK_SRV_MAX_PROC_THREADS)
        {
            SDK_SRV_ERR("Too many thread running!\n");
            HPR_CloseSocketEx(connFd, HPR_TRUE);
            connFd = HPR_INVALID_SOCKET;
            HPR_Sleep(500);
            continue;
        }
       
        /* create a new task to process client request */
        if(pthreadSpawn(NULL, COMMON_PRIO, 200*1024, sdk_srv_proc_srv, 2, connFd, iHasReadLen) != HPR_OK)
        {
            SDK_SRV_FATAL("pthreadSpawn processClientRequest failed\n");
            connFd = HPR_INVALID_SOCKET;
            HPR_CloseSocketEx(connFd, HPR_TRUE);
            HPR_Sleep(1000);
            continue;
        }
        else
        {
            s_struSdkSrvStat.iThreadCnt++;
        }
    }

    HPR_CloseSocket(sockFd);
    sockFd = HPR_INVALID_SOCKET;
    popPthreadInfo(pTaskName, strlen(pTaskName));
    s_struSdkSrvStat.bRun = HPR_FALSE;

    return;
}

static int sdk_srv_flush_port(void)
{
    HPR_SOCK_T iSock;
    HPR_ADDR_T struLocalAddr, struSrvAddr;
    HPR_INT32 iCmdLen = 0;
    HPR_INT32 iSendLen = 0;
    bzero(&struLocalAddr, sizeof(struLocalAddr));
    iSock = HPR_CreateSocket(AF_INET, SOCK_STREAM, 0);
    if(HPR_INVALID_SOCKET == iSock)
    {
        SDK_SRV_ERR("HPR_CreateSocket failed \n");
        return HPR_ERROR;
    }
    if(HPR_OK != HPR_MakeAddrByString(AF_INET, "127.0.0.1", 0, &struLocalAddr))
    {
        SDK_SRV_ERR("HPR_MakeAddrByString error!\n");
        goto errExit;
    }
    if(HPR_OK != HPR_Bind(iSock, &struLocalAddr))
    {
        SDK_SRV_ERR("HPR_Bind failed\n");
        goto errExit;
    }

    
    bzero(&struSrvAddr, sizeof(struSrvAddr));
    if (HPR_OK != HPR_MakeAddrByString(AF_INET, "127.0.0.1", (HPR_UINT16)s_struSdkSrvStat.iPort, &struSrvAddr))
    {
        SDK_SRV_ERR("HPR_MakeAddrByString error!\n");
        goto errExit;
    }

    if(HPR_OK != HPR_ConnectWithTimeOut(iSock, &struSrvAddr, SDK_SRV_SOCK_WAIT_TIME))
    {
        SDK_SRV_ERR("HPR_ConnectWithTimeOut error!:%d\n", HPR_GetSystemLastError());
        goto errExit;
    }

    /**
     * iCmdLen = SDK_SRV_PROTO_MAX_LEN + 1用来标注需要flush port
     */
    iCmdLen = htonl((HPR_INT32)(SDK_SRV_PROTO_MAX_LEN + 1));
    iSendLen = HPR_Sendn(iSock, &iCmdLen, sizeof(iCmdLen), SDK_SRV_SOCK_WAIT_TIME);
    if (iCmdLen != iSendLen)
    {
        SDK_SRV_ERR("HPR_Sendn failed[%d][%d], error[%d][%s]!:%d\n", iCmdLen, iSendLen, errno, strerror(errno));
        goto errExit;
    }

    (void)HPR_CloseSocket(iSock);
    
    return HPR_OK;

errExit:
    (void)HPR_CloseSocket(iSock);
    return HPR_ERROR;
}

HPR_INT32 sdk_srv_stop(HPR_VOID)
{
    SDK_SRV_INFO("start!\n");
    
    if(!s_struSdkSrvStat.bRun)
    {
        return HPR_OK;
    }

    s_struSdkSrvStat.bNeedQuit = HPR_TRUE;
    if(HPR_OK != sdk_srv_flush_port())
    {
        SDK_SRV_ERR("flush port error!\n");
        s_struSdkSrvStat.bNeedQuit = HPR_FALSE;
        return HPR_ERROR;
    }
    
    SDK_SRV_INFO("end!\n");
    return HPR_OK;
}

HPR_INT32 sdk_srv_chg_cfg(HPR_VOID)
{
    SDK_SRV_INFO("start!\n");

    if (HPR_OK != sdk_srv_flush_port())
    {
        SDK_SRV_ERR("flush port error!\n");
        return HPR_ERROR;
    }
    
    SDK_SRV_INFO("end!\n");
    return HPR_OK;    
}
